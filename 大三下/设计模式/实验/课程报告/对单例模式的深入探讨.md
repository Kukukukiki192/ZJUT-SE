# 1 介绍

**定义**：
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一. 这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建. 这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象

**意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点

**主要解决**：一个全局使用的类频繁地创建与销毁

**何时使用**：当您想控制实例数目，节省系统资源的时候

**如何解决**：判断系统是否已经有这个单例，如果有则返回，如果没有则创建

**关键代码**：构造函数是私有的

**注意事项**：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 
instance 被多次实例化

**特点**：

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给所有其他对象提供这一实例

# 2 优缺点

**优点**

- 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）
- 可以避免对资源的多重占用（比如写文件操作）
- 单例模式设置全局访问点，可以优化和共享资源的访问

**缺点**

- 单例模式一般没有接口，扩展困难. 如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则
- 在并发测试中，单例模式不利于代码调试. 在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则

# 3 应用场景

对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例. 单例模式的应用场景主要有以下几个方面

- 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC
- 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号、要求生产唯一的序列号等
- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用
- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等
- 频繁访问数据库或文件的对象
- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套
- 当对象需要被共享的场合. 由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度. 如 Web 中的配置对象、数据库的连接池等

​	在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例（Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行）

​	单例模式在现实生活中的应用也非常广泛，例如公司 CEO、部门经理、一个班级只有一个班主任等都属于单例模型. J2EE 标准中的 ServletContext 和 ServletContextConfig、Spring 框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式. 一些设备管理器也常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件. 还有WEB 中的计数器，不用每次刷新都在数据库里加一次，可以用单例先缓存起来

# 4 结构

单例模式的主要角色：

- 单例类. 只能创建一个实例的类
- 访问类. 使用单例类

![](https://github.com/Kukukukiki192/TyporaImg/raw/main/img/SinglePattern.png)

# 5 实现

> 单例设计模式分类2种：
> 	饿汉式：类加载就会导致该单实例对象被创建
> 	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建


## 5.1 饿汉式-方式1（静态变量方式） 
```java
/**
 * 饿汉式(常用)
 *      静态变量创建类的对象
 
 * 通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例
 * 但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例
 * 这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象(获取唯一可用的对象)
    public static Singleton getInstance() {
        return instance;
    }
}
```
说明：
	方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance. instance对象是随着类的加载而创建的. 如果该对象足够大的话，而一直没有使用就会造成内存的浪费
	它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果
	饿汉式单例实现是线程安全的. 线程不安全问题主要是由于 instance 被实例化多次，采取直接实例化instance 的方式就不会产生线程不安全问题. 但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处

## 5.2 饿汉式-方式2（静态代码块方式） 
```java
/**
 * 恶汉式
 *      在静态代码块中创建该类对象
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```
说明：
	该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建. 所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题

## 5.3 懒汉式-方式1（线程不安全） 
```java
/**
 * 懒汉式
 *  线程不安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
说明：
	从上面代码可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果
	但是，在多线程环境下，会出现线程安全问题. 如果多个线程能够同时进入 if (instance == null) ，并且此时 instance 为 null，那么会有多个线程执行 instance = new Singleton(); 语句，这将导致实例化多次 instance

> 懒汉式与饿汉式横评

|  | **懒汉式😂很懒，拖延症，不到必要时不创建单例实例** | **饿汉式😂饿了，一上来（类加载时）就创建单例** |
| --- | --- | --- |
| 线程安全（多线程环境下能否确保对象仅被创建一次） | 不安全 | 安全 |
| 单例实例创建时机|当Singleton.getInstance()方法被调用时才会创建实例，如果程序由始至终都没有调用该方法，则单例实例永远不会被创建，节省了内存空间和资源|在Singleton被类加载器加载时创建单例对象，并且会把单例变量一直存放在内存的方法区中，直到程序结束才会把单例对象销毁，如果程序由始至终都没有使用该实例，将会造成资源浪费|

 懒汉式有更好的性能，接下来介绍2种通过加锁使得懒汉式在多线程环境中也能线程安全的方法

## 5.4 懒汉式-方式2（单锁 线程安全）

```java
/**
 * 懒汉式
 *  线程安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
说明：
	该方式也实现了懒加载效果，同时又解决了线程安全问题. 但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低. 从下面代码可以看出，其实就是在初始化instance时才会出现线程安全问题，一旦初始化完成就不存在了

## 5.5 懒汉式-方式3（双重检查锁 DCL，即 double-checked locking）
​	再来讨论一下懒汉模式中加锁的问题，对于 `getInstance()` 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机. 由此也产生了一种新的实现模式：双重检查锁模式
```java
/**
 * 双重检查方式
 */
public class Singleton { 

    //私有构造方法
    private Singleton() {}

    private static Singleton instance;

   //对外提供静态方法获取该对象
    public static Singleton getInstance() {
		//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例
        if(instance == null) {
            synchronized (Singleton.class) {
                //抢到锁之后再次判断是否为null,只能有一个线程进入
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
​	双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作
​	要解决双重检查锁模式带来空指针异常问题，只需要使用 `volatile` 关键字(如第二种实现代码所示)，它可以保证(内存)可见性和有序性(防止指令重排序).  声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache这一步. 在读取volatile类型的变量时总会返回最新写入的值

```java
/**
 * 双重检查方式2
 */
public class Singleton {
    private Singleton() {}
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
小结：
	添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全，也不会有性能问题

## 5.6 静态内部类方式
​	静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性. 静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序
```java
/**
 * 静态内部类方式
 *   Singleton 类被装载了，instance 不一定被初始化
 *   SingletonHolder类没有被主动使用，只有通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```
说明：
	第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机才会加载SingletonHolder并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性
小结：
	静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式. 在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费

## 5.7 枚举方式
​	枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式
```java
/**
 * 枚举方式
 */
public enum Singleton {
    INSTANCE;
}
```
说明：
	枚举方式属于饿汉式方式
	枚举方式属于注册式单例，注册式单例就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例. 注册式单例模式还有一种是容器式单例模式，比如IOC容器就属于容器式单例

# 6 存在的问题

## 6.1 问题演示

破坏单例模式：
使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外. 有两种方式，分别是序列化和反射

-  **序列化反序列化**
Singleton类： 
```java
public class Singleton implements Serializable {
    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```
​	Test类： 
```java
public class Test {
    public static void main(String[] args) throws Exception {
        //往文件中写对象
        //writeObject2File();
        //从文件中读取对象
        Singleton s1 = readObjectFromFile();
        Singleton s2 = readObjectFromFile();

        //判断两个反序列化后的对象是否是同一个对象
        System.out.println(s1 == s2);
    }

    private static Singleton readObjectFromFile() throws Exception {
        //创建对象输入流对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:/a.txt"));
        //第一个读取Singleton对象
        Singleton instance = (Singleton) ois.readObject();

        return instance;
    }

    public static void writeObject2File() throws Exception {
        //获取Singleton类的对象
        Singleton instance = Singleton.getInstance();
        //创建对象输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:/a.txt"));
        //将instance对象写出到文件中
        oos.writeObject(instance);
    }
}
```
> 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了单例设计模式. 


-  **反射**
Singleton类： 
```java
public class Singleton {
    //私有构造方法
    private Singleton() {}
    
    private static volatile Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        if(instance != null) {
            return instance;
        }

        synchronized (Singleton.class) {
            if(instance != null) {
                return instance;
            }
            instance = new Singleton();
            return instance;
        }
    }
}
```
​	Test类：   
```java
public class Test {
    public static void main(String[] args) throws Exception {
        //获取Singleton类的字节码对象
        Class clazz = Singleton.class;
        //获取Singleton类的私有无参构造方法对象
        Constructor constructor = clazz.getDeclaredConstructor();
        //取消访问检查
        constructor.setAccessible(true);

        //创建Singleton类的对象s1
        Singleton s1 = (Singleton) constructor.newInstance();
        //创建Singleton类的对象s2
        Singleton s2 = (Singleton) constructor.newInstance();

        //判断通过反射创建的两个Singleton对象是否是同一个对象
        System.out.println(s1 == s2);
    }
}
```
> 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了单例设计模式
>
> 注意：枚举方式不会出现这两个问题


## 6.2 问题的解决

-  **序列化、反序列方式破坏单例模式的解决方法**
在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象
Singleton类： 
```java
public class Singleton implements Serializable {
    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    //下面是为了解决序列化反序列化破解单例模式
    private Object readResolve() {
        return SingletonHolder.INSTANCE;
    }
}
```
​	源码解析：ObjectInputStream类  
```java
public final Object readObject() throws IOException, ClassNotFoundException{
    ...
    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        Object obj = readObject0(false);//重点查看readObject0方法
    .....
}
    
private Object readObject0(boolean unshared) throws IOException {
	...
    try {
		switch (tc) {
			...
			case TC_OBJECT:
				return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法
			...
        }
    } finally {
        depth--;
        bin.setBlockDataMode(oldMode);
    }    
}
    
private Object readOrdinaryObject(boolean unshared) throws IOException {
	...
	//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，
    obj = desc.isInstantiable() ? desc.newInstance() : null; 
    ...
    // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true
    if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
    	// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量
    	// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象. 阻止了单例被破坏. 
    	Object rep = desc.invokeReadResolve(obj);
     	...
    }
    return obj;
}
```

-  **反射方式破解单例的解决方法 **
```java
public class Singleton {
    //私有构造方法
    private Singleton() {
        //反射破解单例模式需要添加的代码
        if(instance != null) {
            throw new RuntimeException();
        }
    }
    
    private static volatile Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {

        if(instance != null) {
            return instance;
        }

        synchronized (Singleton.class) {
            if(instance != null) {
                return instance;
            }
            instance = new Singleton();
            return instance;
        }
    }
}
```
说明:
	这种方式比较好理解. 当通过反射方式调用构造方法进行创建创建时，直接抛异常. 不运行此中操作

# 7 JDK源码解析-Runtime类

Runtime类就是使用的单例设计模式

1.  通过源代码查看使用的是哪种单例模式 
```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
}
```
​	从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的

2.  使用Runtime类中的方法  
```java
public class RuntimeDemo {
    public static void main(String[] args) throws IOException {
        //获取Runtime类对象
        Runtime runtime = Runtime.getRuntime();

        //返回 Java 虚拟机中的内存总量
        System.out.println(runtime.totalMemory());
        //返回 Java 虚拟机试图使用的最大内存量
        System.out.println(runtime.maxMemory());

        //创建一个新的进程执行指定的字符串命令，返回进程对象
        Process process = runtime.exec("ipconfig");
        //获取命令执行后的结果，通过输入流获取
        InputStream inputStream = process.getInputStream();
        byte[] arr = new byte[1024 * 1024* 100];
        int b = inputStream.read(arr);
        System.out.println(new String(arr,0,b,"gbk"));
    }
}
```

# 8 总结

## 8.1 如何实现一个线程安全的单例模式？ 

- 通过饿汉模式、静态内部类方式
- 通过懒汉模式在对象实例化时用 synchronize 关键字双重检查
- 通过枚举实现

## 8.2 如何做到线程安全？

- 借助 synchronize 关键字实现线程安全
- 饿汉式、静态内部类方式，这两种方式都是通过定义静态变量，以保证单例对象在类初始化时候被实例化. 这其实是利用了ClassLoader的线程安全加载机制ClassLoader的loadClass方法在加载类的时候，实际上使用了 synchronized 关键字；所以除非被重写，这个方法在默认在线程的整个装载中都是线程安全的，所以使用类加载中创建的对象是线程安全的
- 枚举实现的单例是枚举底层依赖Enum类实现的，它的所有成员变量都是静态的，并且在静态代码块中实例化的，所以枚举是天然的线程安全的

## 8.3 如何破坏单例？

- 序列化和反序列化破坏单例
- 通过反射破坏单例

## 8.4 什么情况使用哪种实现方式？
​	一般情况下，不建议使用第 3 种和第 4 种懒汉方式，建议使用饿汉方式. 只有在要明确实现 lazy loading 效果时，才会使用第 6 种静态内部类方式. 如果涉及到反序列化创建对象时，可以尝试使用第 7 种枚举方式. 如果有其他特殊的需求，可以考虑使用第 5 种双检锁方式
