## 演讲稿

### 概述

p4

在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。
例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等；这里给出了3个去银行办理业务的人A、B、C各自的业务办理流程，那么我们如何用代码来实现上述功能呢

p5

我们可以思考一下，如果对每个办理人的业务都实现一个类的话，会带来这样的问题：

1. 一方面，取号、排队、评分这样的相同操作会出现很多重复代码，导致代码冗余；如果想修改其中一个操作，那每个人的代码都要修改，非常麻烦
2. 另一方面，如果我们想临时添加一个新办理人，上述操作又要重新实现一遍，又多了一份重复代码

p6

那么解决方法就是，通过多个子类继承一个父类，对相同功能的代码进行抽取，不同功能部分的代码分别实现 

很明显我们可以发现，取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现；但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。

p7

这样不仅可以达到删减重复代码、只需修改一处代码就可更新所有代码的目的，也能让添加新的办理人的步骤变得更容易

**一处更改**是指相同功能的代码只需在抽象类中的具体方法中修改，不同功能部分的代码只需修改某个具体子类实现的某个抽象方法

 p8

通过这个简单的例子，我们能方便理解模板方法的定义和结构

模板方法模式包含以下主要角色：

* 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

  * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法，完成固定的逻辑。容易识别，**final**关键字防止子类覆盖

  * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：

    * 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。

    * 具体方法(Concrete Method) ：一个具体方法由一个**抽象类或具体类**声明并实现，其子类可以进行覆盖也可以直接继承。

    * 钩子方法(Hook Method) ：在抽象类中已经实现，包括**用于判断的逻辑方法**和**需要子类重写的空方法**两种。

      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

* 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。

### 案例实现

钩子方法：在抽象类中已经实现，用于判断的逻辑方法，返回值类型为boolean类型；在具体子类中重写，并实现抽象方法的空方法

客户端依赖于抽象类-豆浆类，抽象类创建(实例化)具体子类，调用抽象父类的模板方法，实际上是父类调用子类实现的抽象方法
运行结果：1、3、4步骤是不变的，步骤2根据豆浆种类加入了不同配料；纯豆浆不加配料，因为在纯豆浆类中重写了钩子方法将返回值设为false，则它调用父类模板方法，模板方法调用它的add方法时是一个空实现

#### JDK源码应用

抽象类InputStream有3个重载的read方法：无参 1个参数(字节数组) 3个参数

从上面代码可以看到，无参的 `read()` 方法是抽象方法，要求子类必须实现。而 `read(byte b[])` 方法调用了 `read(byte b[], int off, int len)` 方法，所以在此处重点看的方法是带三个参数的方法。 

如果想一次性读取多个字节数据，我们要调用1参read()，它又调用了重载的3参read()，而在该方法中的这2行可以看到又调用了无参的抽象 `read()` 方法，所以其根本调用的是子类中的read()，这就是反向控制，而反向控制就是模板方法模式的思想 

3参read()就是模板方法，里面定义了算法的框架，就是多次调用read()，并把每次调用获取到的字节数据存到数组里

总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。

其它在源码中的应用：JdbcTemplate中的execute方法



## 提问

### 和其它设计模式的关系

#### 策略模式

模板方法模式的主要思想：

定义一个算法流程，将一些特定步骤的具体实现、延迟到子类。使得可以在不改变算法流程的情况下，通过不同的子类、来实现“定制”流程中的特定的步骤。

策略模式的主要思想：

使不同的算法可以被相互替换，而不影响客户端的使用。

在思想和意图上看，模板方法更加强调：
1）定义一条线（算法流程），线上的多个点是可以变化的（具体实现在子类中完成），线上的多个点一定是会被执行的，并且一定是按照特定流程被执行的。
2）算法流程只有唯一的入口，对于点的访问是受限的【通常用受保护的虚函数来定义可变点】。

策略模式更注重于： 一个“策略”是一个 整体的(完整的) 算法，算法是可以被整体替换的。而模板方法只能被替换其中的特定点，算法流程是固定不可变的。

#### 工厂模式

　工厂方法模式是类的创建模式，又叫做虚拟构造子模式或者多态性工厂模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。

　模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的构造子类可以以不同的方法实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。

模板模式经常使用工厂模式



### 优缺点

ppt上 重点



### 使用场景

1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。

